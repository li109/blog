# Vue2.0源码阅读笔记（七）：组件
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 一、组件的本质
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 二、注册组件
&emsp;&emsp;在Vue中组件注册分为两种：局部注册、全局注册。全局注册是通过 *Vue.component* 方法进行的，局部注册是通过在实例化组件时添加 *components* 选项完成的。<br/>
&emsp;&emsp;下面详细介绍组件注册以及相关内容。<br/>
### 1、Vue.options.components
&emsp;&emsp;*Vue.options* 的 *components* 属性是在 */src/core/global-api/index.js* 文件中调用 *initGlobalAPI* 函数来定义的。<br/>
```js
initGlobalAPI(Vue)

// initGlobalAPI 代码
Vue.options = Object.create(null)
ASSET_TYPES.forEach(type => {
  Vue.options[type + 's'] = Object.create(null)
})
Vue.options._base = Vue
extend(Vue.options.components, builtInComponents)

// ASSET_TYPES
export const ASSET_TYPES = [
  'component',
  'directive',
  'filter'
]

// builtInComponents
import KeepAlive from './keep-alive'
export default { KeepAlive }
```
&emsp;&emsp;在 */src/platforms/web/runtime/index.js* 文件中会对 *Vue.options.components* 进一步赋值。<br/>
```js
import platformComponents from './components/index'

extend(Vue.options.components, platformComponents)

// platformComponents
import Transition from './transition'
import TransitionGroup from './transition-group'

export default {
  Transition,
  TransitionGroup
}
```
&emsp;&emsp;最终 *Vue.options.components* 中会包含三个内置组件：<br/>
```js
Vue.options.components = {
  KeepAlive: {/* ... */},
  Transition: {/* ... */},
  TransitionGroup: {/* ... */}
}
```
&emsp;&emsp;在[《选项合并》](https://juejin.im/post/5c8f60f8e51d45768a6e95f0#heading-9)一文中讲过，资源选项的合并是通过 *mergeAssets* 函数进行的。合并策略是以父选项对象为原型，因此：<br/>
```js
// vm 为Vue实例，即Vue组件
vm.$options.components.prototype = Vue.options.components = {
  KeepAlive: {/* ... */},
  Transition: {/* ... */},
  TransitionGroup: {/* ... */}
}
```
### 2、Vue.extends
&emsp;&emsp;Vue.extends 用来创建一个Vue构造函数的“子类”，精简代码如下：<br/>
```js
Vue.extend = function (extendOptions) {
  /* ... */
  const Sub = function VueComponent (options) {
    this._init(options)
  }
  Sub.prototype = Object.create(Super.prototype)
  Sub.prototype.constructor = Sub
  Sub.cid = cid++
  Sub.options = mergeOptions(
    Super.options,
    extendOptions
  )
  /* ... */
  ASSET_TYPES.forEach(function (type) {
    Sub[type] = Super[type]
  })
  if (name) {
    Sub.options.components[name] = Sub
  }
  /* ... */
  return Sub
}
```
&emsp;&emsp;可以看到 *Vue.extend* 返回的函数 *VueComponent* 跟Vue构造函数一样，都是调用 *_init* 方法进行初始化。*VueComponent* 函数自身也会添加跟Vue相同的静态属性和方法。<br/>
&emsp;&emsp;*VueComponent* 与 Vue 的主要区别是静态属性 *options* 不同。*VueComponent.options* 是将 *Vue.extend* 参数和原有构造函数的 *options* 参数通过 *mergeOptions* 函数进行合并而得到的。<br/>
&emsp;&emsp;另外，会将构造函数添加到自身的 *options.components* 对象属性上，也就是说通过 *VueComponent* 实例化的对象上的属性 *$options.components.prototype* 上除了内置组件还会有自定义组件的构造函数。<br/>
### 3、Vue.component全局注册
&emsp;&emsp;Vue关于资源的静态方法（Vue.component、Vue.directive、Vue.filter）定义如下：<br/>
```js
initAssetRegisters(Vue)

function initAssetRegisters (Vue) {
  ASSET_TYPES.forEach(type => {
    Vue[type] = function (id,definition ){
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        if (process.env.NODE_ENV !== 'production' && type === 'component') {
          validateComponentName(id)
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id
          definition = this.options._base.extend(definition)
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition }
        }
        this.options[type + 's'][id] = definition
        return definition
      }
    }
  })
}
```
&emsp;&emsp;单看 *Vue.component* 方法其定义如下所示：<br/>
```js
Vue.component = function (id, definition){
  if (!definition) {
    return this.options.components[id]
  } else {
      // 组件名合法性检测
      validateComponentName(id)

      if (isPlainObject(definition)) {
        definition.name = definition.name || id
        definition = Vue.extend(definition)
      }
      Vue.options.components[id] = definition
      return definition
  }
}
```
&emsp;&emsp;由以上代码可知，全局注册的实质是**根据全局注册组件选项生成Vue子构造函数，然后将该子构造函数添加到Vue.options.components对象上**。<br/>
### 4、component选项局部注册
&emsp;&emsp;在使用 *components* 选项来注册组件时，会将要注册组件信息存储在当前组件实例的 *$options.components* 对象上。<br/>
&emsp;&emsp;在局部组件根据渲染函数生成对应VNode时，会调用所在组件实例的 *extend* 方法根据注册信息生成对应的子构造函数。<br/>
## 三、组件解析
&emsp;&emsp;组件的解析过程和普通标签一样：根据模板生成渲染函数、根据渲染函数生成虚拟DOM、根据虚拟DOM生成真实DOM。<br/>
&emsp;&emsp;下面以一个简单的例子来说明组件的解析过程：<br/>
```html
<body>
  <div id="app"></div>
</body>
<script>
  var ComponentA = {
    template: '<div>组件A</div>'
  }
  var vue = new Vue({
    el: '#app',
    template: `<div id="app" class="home"><component-a></component-a></div>`,
    components: {
      "component-a": ComponentA
    }
  })
</script>
```
### 1、渲染函数
&emsp;&emsp;模板中组件生成的渲染函数比较简单，跟标签一样由 \_c() 函数包裹。\_c() 的第一个参数为组件名，第二个参数为组件属性对象，第三个参数为使用 \<slot\> 接收的内容。<br/>
```js
function anonymous() {
  with(this){
    return _c(
      'div',
      {staticClass:"home",attrs:{"id":"app"}},
      [_c('component-a')],
      1
    )
  }
}
```
&emsp;&emsp;组件的具体配置参数信息存储在 *vm.$options.components* 中：<br/>
```js
vm.$options.components = {
  "component-a" : {
    template: "<div>组件A</div>"
  }
}
```
### 2、VNode
&emsp;&emsp;组件生成VNode是调用渲染函数中的 *_c()* 完成的，*_c()* 最终会调用 *_createElement* 来生成VNode。*_createElement* 中关于组件处理的代码如下所示：<br/>
```js
// context 为当前组件实例
if ((!data || !data.pre) && 
  isDef(Ctor = resolveAsset(context.$options, 'components', tag){
    vnode = createComponent(Ctor, data, context, children, tag);
}
```
#### （一）resolveAsset 获取组件注册信息
&emsp;&emsp;*resolveAsset* 对组件类型资源的处理代码如下：<br/>
```js
function resolveAsset (options,type,id,warnMissing) {
  if (typeof id !== 'string') { return }
    var assets = options[type];
    if (hasOwn(assets, id)) { return assets[id] }

    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
    
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }

    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if (warnMissing && !res) {
      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id,options);
    }
    return res
  }
```
&emsp;&emsp;该函数对组件的处理比较有意思，首先是关于组件名称的问题：**在模板中使用的组件名称，在组件注册时可以有三种形式**。注册时可以跟使用时保持一致，也可以使用驼峰命名或者首字母大写的驼峰命名。<br/>
&emsp;&emsp;其次是关于组件局部注册以及全局注册的问题：局部注册的组件会保存在 *vm.$options.components* 中，全局注册的组件保存在 *Vue.options.components* 中，而 *Vue.options.components* 在 *vm.$options.components* 的原型链上。<br/>
&emsp;&emsp;*resolveAsset* 函数查询组件注册信息会先查注册的局部变量，如果找不到再沿着原型链查询。这就是局部组件只能自身使用，全局注册的组件能够全局使用的原因。<br/>
#### （二）createComponent
&emsp;&emsp;组件VNode生成函数 *createComponent* 的精简代码如下所示：<br/>
```js
function createComponent (Ctor,data,context,children,tag){
  if (isUndef(Ctor)) { return }

  const baseCtor = context.$options._base
  if (isObject(Ctor)) {Ctor = baseCtor.extend(Ctor)}
  /* 省略异步组件相关处理代码 */
  data = data || {}
  resolveConstructorOptions(Ctor)
  /* 省略v-model相关处理代码 */
  const propsData = extractPropsFromVNodeData(data, Ctor, tag)
  /* 省略函数式组件相关处理代码 */
  const listeners = data.on
  data.on = data.nativeOn
  /* 省略抽象组件相关处理代码 */
  installComponentHooks(data)

  const name = Ctor.options.name || tag
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  )
  /* 省略WEEX相关代码 */
  return vnode
}
```
&emsp;&emsp;首先是根据局部组件注册信息调用 *extend* 方法生成子构造函数，然后调用 *resolveConstructorOptions* 函数来更新子构造函数的 *options* 属性。这里会有一个疑问：**在 extend 方法中已经使用 mergeOptions 方法完成对子构造函数 options 属性合并更新，为什么还要调用 resolveConstructorOptions 函数处理 options？**<br/>
```js
function resolveConstructorOptions (Ctor) {
  let options = Ctor.options
  if (Ctor.super) {
    const superOptions = resolveConstructorOptions(Ctor.super)
    const cachedSuperOptions = Ctor.superOptions
    if (superOptions !== cachedSuperOptions) {
      Ctor.superOptions = superOptions
      const modifiedOptions = resolveModifiedOptions(Ctor)
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions)
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) {
        options.components[options.name] = Ctor
      }
    }
  }
  return options
}
```
&emsp;&emsp;这是为了防止在组件构造函数创建以后使用全局 *mixins* 更改父构造函数的选项，*resolveConstructorOptions* 函数的作用就是根据原型链上对象的 *options* 值来更新子构造函数的 *options*。<br/>
&emsp;&emsp;接着调用 *extractPropsFromVNodeData* 函数来从当前实例中提取局部组件 *props* 的值，调用 *installComponentHooks* 来在 *data* 属性上安装组件的钩子函数。<br/>
&emsp;&emsp;最后使用 *new VNode()* 来生成组件类型VNode，传入的第一个参数是根据组件名拼接处理的；第三个参数不传，也就是说组件VNode没有 *children* 属性；与生成其他类型VNode不同，第七个参数会传入组件选项对象 *componentOptions*；第八个参数会根据是否为异步组件而传入不同的值。<br/>
#### （三）installComponentHooks
&emsp;&emsp;组件钩子安装函数 *installComponentHooks* 以及相关代码如下所示：<br/>
```js
const componentVNodeHooks = {
  init (vnode, hydrating) {/* 省略具体实现 */},
  prepatch (oldVnode, vnode) {/* 省略具体实现 */},
  insert (vnode) {/* 省略具体实现 */},
  destroy (vnode) {/* 省略具体实现 */}
}

const hooksToMerge = Object.keys(componentVNodeHooks)

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;
    }
  }
}
function mergeHook (f1, f2) {
  const merged = (a, b) => {
    f1(a, b)
    f2(a, b)
  }
  merged._merged = true
  return merged
}
```
&emsp;&emsp;组件钩子函数生成逻辑比较简单：将 *data.hook* 与 *componentVNodeHooks* 中的函数加以合并，合并策略为将同名函数合并到同一函数中。<br/>
&emsp;&emsp;如果原本 *data.hook* 中没有钩子函数，则最终 *data.hook* 的值如下所示：<br/>
```js
data.hook = componentVNodeHooks = {
  init (vnode, hydrating) {/* 省略具体实现 */},
  prepatch (oldVnode, vnode) {/* 省略具体实现 */},
  insert (vnode) {/* 省略具体实现 */},
  destroy (vnode) {/* 省略具体实现 */}
}
```
&emsp;&emsp;最终有四个钩子函数：init、prepatch、insert、destroy。钩子函数的具体功能在后面用到时再详细讲解。<br/>
### 3、patch
&emsp;&emsp;在 patch 的过程中，组件类型VNode生成真实DOM是调用函数 *createPatchFunction* 中的内部函数 *createComponent* 来完成的。<br/>
#### （一）createComponent
&emsp;&emsp;函数 *createComponent* 代码如下所示：<br/>
```js
function createPatchFunction(backend) {
  /* ... */
  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false);
      }
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }
  /* ... */  
}
```
&emsp;&emsp;组件类型VNode生成DOM的过程为：调用 *data.hook.init* 方法生成组件实例 *componentInstance* 属性，然后调用 *initComponent* 函数完成组件初始化，最后调用 *insert* 方法将生成的DOM插入<br/>
#### （二）init钩子函数
&emsp;&emsp;钩子函数 *init* 函数代码如下所示：<br/>
```js
init (vnode, hydrating) {
  if (
    vnode.componentInstance &&
    !vnode.componentInstance._isDestroyed &&
    vnode.data.keepAlive
  ) {
    const mountedNode = vnode
    componentVNodeHooks.prepatch(mountedNode, mountedNode)
  } else {
    const child = 
    vnode.componentInstance = 
    createComponentInstanceForVnode(vnode,activeInstance)

    child.$mount(hydrating ? vnode.elm : undefined, hydrating)
  }
}
```
&emsp;&emsp;<br/>
#### （三）初始化组件函数initComponent
&emsp;&emsp;<br/>
```js
function initComponent (vnode, insertedVnodeQueue) {
  if (isDef(vnode.data.pendingInsert)) {
    insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
    vnode.data.pendingInsert = null;
  }
  vnode.elm = vnode.componentInstance.$el;
  if (isPatchable(vnode)) {
    invokeCreateHooks(vnode, insertedVnodeQueue);
    setScope(vnode);
  } else {
    registerRef(vnode);
    insertedVnodeQueue.push(vnode);
  }
}
```
&emsp;&emsp;<br/>
## 四、内置组件
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
### 1、Transition
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
### 2、TransitionGroup
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
### 3、KeepAlive
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 五、slot
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 六、函数式组件
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 七、异步组件
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 八、总结
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>