# Vue2.0源码阅读笔记（七）：组件
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 一、组件的本质
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 二、注册组件
&emsp;&emsp;在Vue中组件注册分为两种：局部注册、全局注册。全局注册是通过 *Vue.component* 方法进行的，局部注册是通过在实例化组件时添加 *components* 选项完成的。<br/>
&emsp;&emsp;下面详细介绍组件注册以及相关内容。<br/>
### 1、Vue.options.components
&emsp;&emsp;*Vue.options* 的 *components* 属性是在 */src/core/global-api/index.js* 文件中调用 *initGlobalAPI* 函数来定义的。<br/>
```js
initGlobalAPI(Vue)

// initGlobalAPI 代码
Vue.options = Object.create(null)
ASSET_TYPES.forEach(type => {
  Vue.options[type + 's'] = Object.create(null)
})
Vue.options._base = Vue
extend(Vue.options.components, builtInComponents)

// ASSET_TYPES
export const ASSET_TYPES = [
  'component',
  'directive',
  'filter'
]

// builtInComponents
import KeepAlive from './keep-alive'
export default { KeepAlive }
```
&emsp;&emsp;在 */src/platforms/web/runtime/index.js* 文件中会对 *Vue.options.components* 进一步赋值。<br/>
```js
import platformComponents from './components/index'

extend(Vue.options.components, platformComponents)

// platformComponents
import Transition from './transition'
import TransitionGroup from './transition-group'

export default {
  Transition,
  TransitionGroup
}
```
&emsp;&emsp;最终 *Vue.options.components* 中会包含三个内置组件：<br/>
```js
Vue.options.components = {
  KeepAlive: {/* ... */},
  Transition: {/* ... */},
  TransitionGroup: {/* ... */}
}
```
&emsp;&emsp;在[《选项合并》](https://juejin.im/post/5c8f60f8e51d45768a6e95f0#heading-9)一文中讲过，资源选项的合并是通过 *mergeAssets* 函数进行的。合并策略为以父选项对象为原型，因此：<br/>
```js
// vm 为Vue实例，即Vue组件
vm.$options.components.prototype = Vue.options.components = {
  KeepAlive: {/* ... */},
  Transition: {/* ... */},
  TransitionGroup: {/* ... */}
}
```
### 2、Vue.extends
&emsp;&emsp;Vue.extends 用来创建一个Vue构造函数的“子类”，精简后代码如下：<br/>
```js
Vue.extend = function (extendOptions) {
  /* ... */
  const Sub = function VueComponent (options) {
    this._init(options)
  }
  Sub.prototype = Object.create(Super.prototype)
  Sub.prototype.constructor = Sub
  Sub.cid = cid++
  Sub.options = mergeOptions(
    Super.options,
    extendOptions
  )
  /* ... */
  ASSET_TYPES.forEach(function (type) {
    Sub[type] = Super[type]
  })
  if (name) {
    Sub.options.components[name] = Sub
  }
  /* ... */
  return Sub
}
```
&emsp;&emsp;可以看到 *Vue.extend* 返回的函数 *VueComponent* 跟Vue构造函数一样，都是调用 *_init* 方法进行初始化。*VueComponent* 函数自身也会添加跟Vue相同的静态属性和方法。<br/>
&emsp;&emsp;*VueComponent* 与 Vue 的主要区别是静态属性 *options* 不同。*VueComponent.options* 是将 *Vue.extend* 参数和原有构造函数的 *options* 参数通过 *mergeOptions* 函数进行合并而得到的。
&emsp;&emsp;另外，会将构造函数添加到自身的 *options.components* 对象属性上，也就是说通过 *VueComponent* 实例化的对象上的属性 *$options.components.prototype* 上除了内置组件还会有自定义组件的构造函数。<br/>
### 3、Vue.component全局注册
&emsp;&emsp;Vue关于资源的静态方法（Vue.component、Vue.directive、Vue.filter）定义如下：<br/>
```js
initAssetRegisters(Vue)

function initAssetRegisters (Vue) {
  ASSET_TYPES.forEach(type => {
    Vue[type] = function (id,definition ){
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        if (process.env.NODE_ENV !== 'production' && type === 'component') {
          validateComponentName(id)
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id
          definition = this.options._base.extend(definition)
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition }
        }
        this.options[type + 's'][id] = definition
        return definition
      }
    }
  })
}
```
&emsp;&emsp;单看 *Vue.component* 方法其定义如下所示：<br/>
```js
Vue.component = function (id, definition){
  if (!definition) {
    return this.options.components[id]
  } else {
      // 组件名合法性检测
      validateComponentName(id)

      if (isPlainObject(definition)) {
        definition.name = definition.name || id
        definition = Vue.extend(definition)
      }
      Vue.options.components[id] = definition
      return definition
  }
}
```
&emsp;&emsp;由以上代码可知，全局注册的实质是**根据全局注册组件选项生成Vue子构造函数，然后将该子构造函数添加到Vue.options.components对象上**。<br/>
### 4、component选项局部注册
&emsp;&emsp;在使用 *components* 选项来注册组件时，会将要注册组件信息存储在当前组件实例的 *$options.components* 对象上。<br/>
&emsp;&emsp;*vm.$options.components*<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
### 5、小结
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 三、组件解析
&emsp;&emsp;组件的解析过程和普通标签一样：根据模板生成渲染函数、根据渲染函数生成虚拟DOM、根据虚拟DOM生成真实DOM。<br/>
&emsp;&emsp;下面以一个简单的例子来说明组件的解析过程：<br/>
```html
<body>
  <div id="app"></div>
</body>
<script>
  var ComponentA = {
    template: '<div>组件A</div>'
  }
  let vue = new Vue({
    el: '#app',
    template: `<div id="app" class="home"><component-a></component-a></div>`,
    components: {
      "component-a": ComponentA
    }
  })
</script>
```
### 1、渲染函数
&emsp;&emsp;模板中组件生成的渲染函数比较简单，跟标签一样由 \_c() 函数包裹。\_c() 的第一个参数为组件名，第二个参数为组件属性对象，第三个参数为使用 \<slot\> 接收的内容。<br/>
```js
function anonymous() {
  with(this){
    return _c(
      'div',
      {staticClass:"home",attrs:{"id":"app"}},
      [_c('component-a')],
      1
    )
  }
}
```
&emsp;&emsp;组件的具体配置参数信息存储在 *vm.$options.components* 中：<br/>
```js
vm.$options.components = {
  "component-a" : {
    template: "<div>组件A</div>"
  }
}
```
### 2、VNode
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
```js
```
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
### 3、生成真实DOM
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 四、内置组件
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
### 1、Transition
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
### 2、TransitionGroup
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
### 3、KeepAlive
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 五、slot
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 六、总结
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>