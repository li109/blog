# Vue2.0源码阅读笔记（五）：模板编译
&emsp;&emsp;在使用Vue进行实际开发的过程中，大多数时候使用模板来创建HTML，模板功能强大且简洁直观，最终模板会编译成渲染函数，本文主要介绍模板编译的具体过程。<br/>
## 一、编译入口
&emsp;&emsp;Vue从能否处理 template 选项的角度分为两个版本：**运行时+编译器**、**只包含运行时**。**运行时+编译器**版本也被称为**完整版**。**只包含运行时**比**完整版**体积小30%左右，使用**只包含运行时**版本需要借助 *vue-loader* 或 *vueify* 等工具编译模板。<br/>
&emsp;&emsp;本文从 web 平台的编译入口开始探究 Vue 完整版的模板编译过程。在 *src/platforms/web/entry-runtime-with-compiler.js* 文件下的 *$mount* 方法中通过 *compileToFunctions* 方法将模板编译成渲染函数。编译方法的生成过程如下如所示：<br/>
![编译入口](../image/vue/template_1.png)
&emsp;&emsp;__首先，向 *createCompilerCreator()* 函数传入 *baseCompile()* 函数，返回值为 *createCompiler()* 函数。__<br/>
&emsp;&emsp;基础编译函数 *baseCompile* 代码如下所示：<br/>
```js
function baseCompile (template, options){
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
}
```
&emsp;&emsp;这几行代码是Vue模板编译的核心，由以上代码可以看出，编译的第一步是将模板通过 *parse* 函数解析成 **AST（抽象语法树）**，第二步优化AST，第三步根据优化后的抽象语法树生成包含渲染函数的对象。<br/>
&emsp;&emsp;**其次，向*createCompiler()* 函数传入基本配置对象 *baseOptions*，返回包含函数属性 *compile* 与 *compileToFunctions* 的对象。**<br/>
&emsp;&emsp;*compile* 函数接收两个参数：模板字符串以及编译选项。另外还通过闭包引用了前面传入的基础编译函数 *baseCompile* 与基本编译配置对象  *baseOptions*。该函数的功能主要有三点：<br/>
>1、合并基础配置选项与传入的编译选项，生成 finalOptions。<br/>
>2、收集编译过程中的错误。<br/>
>3、调用基础编译函数 baseCompile。<br/>

&emsp;&emsp;*compileToFunctions* 函数是将 *compile* 函数作为参数传入 *createCompileToFunctionFn()* 函数生成的返回值。*createCompileToFunctionFn* 函数定义一个缓存变量 *cache*，然后返回函数 *compileToFunctions*。模板字符串的编译比较费时，使用缓存变量 *cache* 是为了防止重复编译，从而提升性能。<br/>
&emsp;&emsp;*compileToFunctions* 函数接受三个参数：模板字符串、编译选项、Vue实例。该函数的主要作用有以下五点：<br/>
>1、缓存编译结果，防止重复编译。<br/>
>2、检测内容安全策略，保证 *new Function()* 能够使用。<br/>
>3、调用 compile 函数将模板字符串转成渲染函数字符串<br/>
>4、调用 createFunction 函数将渲染函数字符串转成真正的渲染函数<br/>
>5、打印编译错误。<br/>

&emsp;&emsp;**最后，将要编译的模板字符串、编译选项与 Vue 的实例对象传入 *compileToFunctions* 函数，返回包含函数属性 *render* 与 *staticRenderFns* 的对象。**<br/>
&emsp;&emsp;*render* 方法为最终的生成的渲染函数，*staticRenderFns* 方法为静态渲染函数，在优化渲染时使用。<br/>
&emsp;&emsp;Vue利用函数**柯里化**的技巧生成编译模板的方法，在初读代码的时候让人感觉十分繁琐，实际却是设计的十分巧妙。<br/>
&emsp;&emsp;这样设计的原因是因为 Vue 能够在不同平台运行，比如在服务器端做SSR，也可以在weex下使用。不同平台都会有编译过程，所依赖的基本编译选项 baseOptions 会有所不同。Vue 将基础的编译过程抽离出来，并且可以在多处添加编译器选项，然后将添加的编译器选项和基本编译选项合并起来，最终灵活实现在不同平台下编译的目的。<br/>
## 二、生成AST
&emsp;&emsp;关于 AST 的概念参照如下维基百科的描述：<br/>
>&emsp;&emsp;在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。<br/>
>&emsp;&emsp;在源代码的翻译和编译过程中，语法分析器创建出分析树，然后从分析树生成AST。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。<br/>

&emsp;&emsp;Vue 编译过程的核心的第一步是调用 *parse* 方法将模板字符串解析为 AST 。<br/>
```js
const ast = parse(template.trim(), options)
```
&emsp;&emsp;*parse* 的代码在 */src/compiler/parser/index.js* 中。省略具体内容的 *parse* 函数代码如下所示：<br/>
```js
export function parse (template,options){
  let root
  /*省略。。。*/

  parseHTML(template, {
    // 省略一些参数
    start (tag, attrs, unary, start, end) {/*省略具体实现*/},
    end (tag, start, end) {/*省略具体实现*/},
    chars (text, start, end) {/*省略具体实现*/},
    comment (text, start, end) {/*省略具体实现*/}
  })
  return root
}
```
&emsp;&emsp;生成AST的过程分为两步：**词法分析**、**句法分析**。*parse* 函数中实现的功能主要是**句法分析**，**词法分析**功能由 *parse* 内部调用的 *parseHTML* 函数来完成。我们首先分析模板字符串做词法分析的过程。<br/>
### 1、词法分析函数 parseHTML
&emsp;&emsp;*parseHTML* 函数的省略具体细节的代码如下所示：<br/>
```js
export function parseHTML (html, options) {
  const stack = []
  let last, lastTag
  /*省略。。。*/
  while (html) {
    last = html
    if (!lastTag || !isPlainTextElement(lastTag)) {
      let textEnd = html.indexOf('<')

      if (textEnd === 0) {/*省略具体实现*/}

      let text, rest, next

      if (textEnd >= 0) {/*省略具体实现*/}
      if (textEnd < 0) { text = html }

      if (text) { advance(text.length) }

      if (options.chars && text) {
        options.chars(text, index - text.length, index)
      }
    } else {
      /*省略具体实现*/
    }

    if (html === last) {/*省略具体实现*/}
  }

  parseEndTag()

  function advance (n) {
    index += n
    html = html.substring(n)
  }

  function parseStartTag () {/*省略具体实现*/}

  function handleStartTag (match) {/*省略具体实现*/}

  function parseEndTag (tagName, start, end) {/*省略具体实现*/}
}
```
####（一）、整体流程分析
&emsp;&emsp;*parseHTML* 函数的具体功能如下图所示：<br/>
![parser函数](../image/vue/template_2.png)
&emsp;&emsp;*parseHTML* 逐个字符解析模板字符串。在 *while* 循环中，每次解析完一段字符串后都调用 *advance* 函数删除已解析的字符串。<br/>
&emsp;&emsp;在了解具体流程之前，先要弄明白一个问题：**如何判断一个非一元标签是否缺少结束标签呢**？即如何检测出像以下例子中发生错误的情况：<br/>
```html
<div><span></div>
```
&emsp;&emsp;*parseHTML* 函数利用栈的数据结构来实现的：解析到开始标签时，将开始标签推入到数组 *stack* 中，变量 *lastTag* 始终指向栈顶元素。当解析到结束标签时，会与栈顶的开始元素相匹配，如果是一对非一元标签，则将栈顶开始标签推出栈，同时继续向前解析。如果匹配失败或者解析完毕后栈中仍有开始标签，则表示非一元标签未闭合。<br/>
&emsp;&emsp;如上例所示，先将 *\<div\>* 推入数组 *stack* 中，继续解析后将 *\<span\>* 也推入栈中，此时栈顶标签为 *\<span\>*，解析到结束标签 *\</div\>* 时会与栈顶标签对比，*\<span\>* 与 *\</div\>* 不是一对非一元便签，则说明模板字符串缺少 *\<span\>* 的结束标签。<br/>
&emsp;&emsp;*parseHTML* 函数首先判断将要解析的字符串是不是在纯文本标签里的内容，纯文本标签是指 *\<script\>*、*\<style\>*、*\<textarea\>* ，如果为纯文本标签的内容，则抽取纯文本标签里的内容，直接使用传入的 *chars()* 进行处理。<br/>
&emsp;&emsp;如果不是在纯文本标签里的内容，则根据字符 '*<*' 的位置来判断要解析的字符串开头是标签还是文本。如果是文本，则使用传入的 *chars()* 进行处理。<br/>
&emsp;&emsp;如果是标签，则有五种可能性：<br/>
> 1、若是注释标签 \<!----\>，则使用传入的 *comment()* 方法处理注释内容。<br/>
> 2、若是条件注释标签\<!--[]\>，则不做任何处理，直接跳过。<br/>
> 3、若是文档类型声明\<!DOCTYPE\>，则不做任何处理，直接跳过。<br/>
> 4、若是结束标签，则 *parseEndTag()* 函数处理。<br/>
> 5、若是开始标签，则使用 *parseStartTag()* 与 *handleStartTag()* 函数进行处理。<br/>

&emsp;&emsp;总之，*parseHTML* 函数解析到**文本**调用 *chars()* 方法处理，解析到**注释标签**调用 *comment()* 方法处理，解析到**条件注释标签**与**文档类型声明**跳过不做处理， *chars()* 与 *comment()* 作为传入的方法将会在讲解 *parse()* 方法时加以讲解。<br/>
&emsp;&emsp;对开始标签与结束标签的处理相对麻烦一些，在调用传入的处理开始标签与结束标签的函数之前，*parseHTML* 函数会先对其做一些处理。<br/>
####（二）、对结束标签的处理
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
####（三）、对开始标签的处理
&emsp;&emsp;解析开始标签是会首先调用 *parseStartTag()* 函数，然后将函数返回值作为参数传入 *handleStartTag()* 函数进行处理。<br/>
&emsp;&emsp;*parseStartTag()* 函数利用正则表达式来解析开始标签，各项解析结果作为 *match* 对象的属性。<br/>
```js
match = {
  tagName: '', // 开始标签的标签名
  attrs: [], // 标签中各属性的信息数组
  start: startIndex, // 标签开始下标
  unarySlash: undefined || '/', // 判断标签是否为一元标签
  end: endIndex // 标签结束下标
}
```
&emsp;&emsp;*handleStartTag()* 函数接收 *match* 对象作为参数。主要有几个功能<br/>
### 2、句法分析函数 parse
## 三、优化AST
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 四、生成渲染函数
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 五、手写渲染函数
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 六、总结
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>