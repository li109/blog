# Vue2.0源码阅读笔记（五）：模板编译
&emsp;&emsp;在使用Vue进行实际开发的过程中，大多数时候使用模板来创建HTML，模板功能强大且简洁直观，最终模板会编译成渲染函数，本文主要介绍模板编译的具体过程。<br/>
## 一、编译入口
&emsp;&emsp;Vue从能否处理 template 选项的角度分为两个版本：**运行时+编译器**、**只包含运行时**。**运行时+编译器**版本也被称为**完整版**。**只包含运行时**比**完整版**体积小30%左右，使用**只包含运行时**版本需要借助 *vue-loader* 或 *vueify* 等工具编译模板。<br/>
&emsp;&emsp;本文从 web 平台的编译入口开始探究 Vue 完整版的模板编译过程。在 *src/platforms/web/entry-runtime-with-compiler.js* 文件下的 *$mount* 方法中通过 *compileToFunctions* 方法将模板编译成渲染函数。编译方法的生成过程如下如所示：<br/>
![编译入口](../image/vue/template_1.png)
&emsp;&emsp;__首先，向 *createCompilerCreator()* 函数传入 *baseCompile()* 函数，返回值为 *createCompiler()* 函数。__<br/>
&emsp;&emsp;基础编译函数 *baseCompile* 代码如下所示：<br/>
```js
function baseCompile (template, options){
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
}
```
&emsp;&emsp;这几行代码是Vue模板编译的核心，由以上代码可以看出，编译的第一步是将模板通过 *parse* 函数解析成 **AST（抽象语法树）**，第二步优化AST，第三步根据优化后的抽象语法树生成包含渲染函数的对象。<br/>
&emsp;&emsp;**其次，向*createCompiler()* 函数传入基本配置对象 *baseOptions*，返回包含函数属性 *compile* 与 *compileToFunctions* 的对象。**<br/>
&emsp;&emsp;*compile* 函数接收两个参数：模板字符串以及编译选项。另外还通过闭包引用了前面传入的基础编译函数 *baseCompile* 与基本编译配置对象  *baseOptions*。该函数的功能主要有三点：<br/>
>1、合并基础配置选项与传入的编译选项，生成 finalOptions。<br/>
>2、收集编译过程中的错误。<br/>
>3、调用基础编译函数 baseCompile。<br/>

&emsp;&emsp;*compileToFunctions* 函数是将 *compile* 函数作为参数传入 *createCompileToFunctionFn()* 函数生成的返回值。*createCompileToFunctionFn* 函数定义一个缓存变量 *cache*，然后返回函数 *compileToFunctions*。模板字符串的编译比较费时，使用缓存变量 *cache* 是为了防止重复编译，从而提升性能。<br/>
&emsp;&emsp;*compileToFunctions* 函数接受三个参数：模板字符串、编译选项、Vue实例。该函数的主要作用有以下五点：<br/>
>1、缓存编译结果，防止重复编译。<br/>
>2、检测内容安全策略，保证 *new Function()* 能够使用。<br/>
>3、调用 compile 函数将模板字符串转成渲染函数字符串<br/>
>4、调用 createFunction 函数将渲染函数字符串转成真正的渲染函数<br/>
>5、打印编译错误。<br/>

&emsp;&emsp;**最后，将要编译的模板字符串、编译选项与 Vue 的实例对象传入 *compileToFunctions* 函数，返回包含函数属性 *render* 与 *staticRenderFns* 的对象。**<br/>
&emsp;&emsp;*render* 方法为最终的生成的渲染函数，*staticRenderFns* 方法为静态渲染函数，在优化渲染时使用。<br/>
&emsp;&emsp;Vue利用函数**柯里化**的技巧生成编译模板的方法，在初读代码的时候让人感觉十分繁琐，实际却是设计的十分巧妙。<br/>
&emsp;&emsp;这样设计的原因是因为 Vue 能够在不同平台运行，比如在服务器端做SSR，也可以在weex下使用。不同平台都会有编译过程，所依赖的基本编译选项 baseOptions 会有所不同。Vue 将基础的编译过程抽离出来，并且可以在多处添加编译器选项，然后将添加的编译器选项和基本编译选项合并起来，最终灵活实现在不同平台下编译的目的。<br/>
## 二、生成AST
&emsp;&emsp;Vue 编译过程的核心的第一步是调用 *parse* 方法将模板字符串解析为 AST 。关于 AST 的概念参照如下维基百科的描述：<br/>
>&emsp;&emsp;在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。<br/>
>&emsp;&emsp;在源代码的翻译和编译过程中，语法分析器创建出分析树，然后从分析树生成AST。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。<br/>

&emsp;&emsp;对 *parse* 函数的调用在 *baseCompile* 函数中进行，代码如下：<br/>
```js
const ast = parse(template.trim(), options)
```
&emsp;&emsp;Vue 关于生成 AST 的代码都放在 */src/compiler/parser* 文件夹中。解析函数 *parse* 的代码在 */src/compiler/parser/index.js* 中。省略具体内容的 *parse* 函数代码如下所示：<br/>
```js
export function parse (template,options){
  let root
  /*省略。。。*/

  parseHTML(template, {
    // 省略一些参数
    start (tag, attrs, unary, start, end) {/*省略具体实现*/},
    end (tag, start, end) {/*省略具体实现*/},
    chars (text, start, end) {/*省略具体实现*/},
    comment (text, start, end) {/*省略具体实现*/}
  })
  return root
}
```
&emsp;&emsp;<br/>
### 1、parseHTML函数
&emsp;&emsp;*parseHTML* 函数的省略具体细节的代码如下所示：<br/>
```js
export function parseHTML (html, options) {
  /*省略。。。*/
  while (html) {
    last = html
    if (!lastTag || !isPlainTextElement(lastTag)) {
      let textEnd = html.indexOf('<')

      if (textEnd === 0) {/*省略具体实现*/}

      let text, rest, next

      if (textEnd >= 0) {/*省略具体实现*/}
      if (textEnd < 0) { text = html }

      if (text) { advance(text.length) }

      if (options.chars && text) {
        options.chars(text, index - text.length, index)
      }
    } else {
      /*省略具体实现*/
    }

    if (html === last) {/*省略具体实现*/}
  }

  parseEndTag()

  function advance (n) {
    index += n
    html = html.substring(n)
  }

  function parseStartTag () {/*省略具体实现*/}

  function handleStartTag (match) {/*省略具体实现*/}

  function parseEndTag (tagName, start, end) {/*省略具体实现*/}
}
```
&emsp;&emsp;*parseHTML* 函数的具体功能如下图所示：<br/>
![parser函数](../image/vue/template_2.png)
### 2、对注释标签的处理
### 3、对结束标签的处理
### 4、对开始标签的处理
### 5、对文本的处理
## 三、优化AST
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 四、生成渲染函数
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 五、手写渲染函数
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 六、总结
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>