# Vue2.0源码阅读笔记（十）：指令
&emsp;&emsp;指令是带有 v- 前缀的特殊特性，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。<br/>
&emsp;&emsp;Vue2.0 内置了形如v-bind、v-on等指令，如果需要对普通 DOM 元素进行底层操作还可以使用自定义指令。<br/>
## 一、自定义指令
&emsp;&emsp;在Vue2.0 中，可以通过自定义指令对普通 DOM 元素进行底层操作。一个指令定义对象可以提供如下几个钩子函数：<br/>
> 1、bind：指令第一次绑定到元素时调用，只调用一次。<br/>
> 2、inserted：被绑定元素插入父节点时调用。<br/>
> 3、update：所在组件的VNode更新时调用。<br/>
> 4、componentUpdated：指令所在组件的VNode及其子VNode全部更新够调用。<br/>
> 5、unbind：指令与元素解绑时调用，只调用一次。<br/>

&emsp;&emsp;通过如下示例来阐述源码中对自定义指令的处理过程：<br/>
```html
<body>
  <div id="app"></div>
</body>
<script>
  let vm = new Vue({
    el: '#app',
    template: '<div>' +
      '<input v-focus>' +
      '</div>',
    directives: {
      focus: {
        inserted: function (el) {
          el.focus()
        }
      }
    }
  })
</script>
```
### 1、全局注册与局部注册
&emsp;&emsp;**指令**、**组件**和**过滤器**在Vue中称为**资源**。可以通过全局API进行全局注册，也可以通过具体选项进行局部注册。组件的全局注册和组件注册在[《组件》](https://juejin.im/post/5da42eb16fb9a04dfd267369)一文中详细阐述过，指令的处理与之类似，这里简要说明。<br/>
&emsp;&emsp;自定义指令全局注册的方法如下所示：<br/>
```js
Vue.directive = function (id, definition) {
  if (!definition) {
    return this.options.directives[id]
  } else {
    if (typeof definition === 'function') {
      definition = { bind: definition, update: definition };
    }
    Vue.options.directives[id] = definition;
    return definition
  }
}
```
&emsp;&emsp;Vue.directive 方法功能比较简单：将自定义指令的名字与配置对象转化成 Vue.options.directives 对象上的键值对。当配置对象为函数时，将该函数当成 bind 与 update 的钩子函数内容来处理，这是因为Vue提供了这种函数简写的方式，在[《选项合并》](https://juejin.im/post/5c8f60f8e51d45768a6e95f0)中有过详细阐述。<br/>
&emsp;&emsp;使用 directives 选项来注册指令，会将自定义指令信息存储在当前组件实例的 $options.directives 对象上。<br/>
### 2、模板编译
&emsp;&emsp;带有自定义指令的标签在生成AST时，会调用 processElement 函数对自定义指令进行处理。<br/>
```js
function processElement (element,options) {
  /* ... */
  processAttrs(element);
  return element
}
```
&emsp;&emsp;processElement 函数会将标签上的属性解析到元素对象的 attrsList 与 attrsMap 属性中，然后调用 processAttrs 函数处理标签上的属性。如果有指令属性，则将其放入到元素对象的 directives 数组属性中。<br/>
&emsp;&emsp;模板编译的 codegen 阶段，在执行 genData 时会根据 el.directives 将指令信息存入到 el.data 字符串中。<br/>
&emsp;&emsp;渲染函数最终根据标签名称el.tag、标签数据el.data、子节点children共同生成。实例中的模板经过编译后生成的渲染函数如下所示：<br/>
```js
_c(
  'div',
  [
    _c(
      'input',
      {
        directives:[
          {
            name:"focus",
            rawName:"v-focus"
          }
        ]
      }
    )
  ]
)
```
### 3、生成VNode
&emsp;&emsp;调用 Vue.prototype._render 方法生成VNode，本质是通过调用渲染函数来完成的。渲染函数中的 _c() 是 createElement 的别称，在函数内部通过调用 _createElement 函数来生成VNode。<br/>
```js
function _createElement (context,tag,data,children,normalizationType){
  /* ... */
  if (config.isReservedTag(tag)) {
    vnode = new VNode(
      config.parsePlatformTagName(tag), data, children,undefined, undefined, context
    );
  }
  /* ... */    
}
```
&emsp;&emsp;根据示例的渲染函数生成的VNode如下所示：<br/>
```js
vnode = {
  tag: "div",
  children: [
    {
      tag: "input",
      data: {
        directives: [
          {
            name: "focus",
            rawName: "v-focus"
          }
        ]
      }
      /* 省略其它属性 */
    }
  ]
  /* 省略其它属性 */
}
```
### 4、patch
&emsp;&emsp;在 patch 过程中，会调用 createElm 函数来生成真实DOM并插入到DOM树中。<br/>
```js
function createElm (/* ... */){
    /* 省略... */
    createChildren(vnode, children, insertedVnodeQueue);
    if (isDef(data)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
    }
    insert(parentElm, vnode.elm, refElm);
    /* 省略... */
}

function invokeCreateHooks (vnode, insertedVnodeQueue) {
  for (var i = 0; i < cbs.create.length; ++i) {
    cbs.create[i](emptyNode, vnode);
  }
  i = vnode.data.hook;
  if (isDef(i)) {
    if (isDef(i.create)) { i.create(emptyNode, vnode); }
    if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
  }
}
```
&emsp;&emsp;关于 cbs 中各阶段的钩子函数的详细阐述可参看[《Virtual DOM》](https://juejin.im/post/5d536743e51d456205410382#heading-13)。<br/>
```js
cbs = {
  create: [
    /* 省略... */
    function updateDirectives (oldVnode, vnode) {/*省略具体代码*/}
  ]
  /* 省略... */
}
```
&emsp;&emsp;在 updateDirectives 方法中，如果虚拟DOM的 data.directives 属性存在，会调用内部方法 _update 。该方法比较很重要，自定义指令提供的钩子都在该函数中进行处理，下面分步详细解读该函数：<br/>
```js
function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  /* 省略... */
}
```
&emsp;&emsp;函数首先定义一些变量，变量的具体含义如下所示：<br/>
> isCreate：指令所在的元素节点是否被创建。<br/>
> isDestroy：指令所在的元素节点是否被销毁。<br/>
> oldDirs：旧元素节点上的指令。<br/>
> newDirs：新元素节点上的指令。<br/>
> dirsWithInsert：拥有 inserted 钩子函数的指令。<br/>
> dirsWithPostpatch：拥有 componentUpdated 钩子函数的指令。<br/>

&emsp;&emsp;在 _update 函数中，会调用 callHook 来调用具体的钩子函数。<br/>
```js
function callHook (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}
```
&emsp;&emsp;接着说 _update 函数，在定义变量之后处理新VNode存在的情况。代码如下所示：<br/>
```js
function _update (oldVnode, vnode) {
  /* 省略... */
  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      callHook(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }
  /* 省略... */
}
```
&emsp;&emsp;当新VNode存在而旧VNode不存在时，说明新VNode是新创建的，未与自定义指令绑定，此时第一次绑定调用 bind 钩子函数，若有 inserted 钩子函数，则将指令存入 dirsWithInsert 数组。<br/>
&emsp;&emsp;当新VNode和旧VNode都存在时，说明是在进行VNode更新。此时调用 update 钩子函数，若有 componentUpdated 钩子函数，则将指令存入 dirsWithPostpatch 数组。<br/>
&emsp;&emsp;然后是对 inserted 与 componentUpdated 钩子函数的处理：<br/>
```js
function _update (oldVnode, vnode) {
  /* 省略... */
  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
       mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }
  /* 省略... */
}
```
&emsp;&emsp;mergeVNodeHook 函数接收三个参数：def、 hookKey、hook。如果第一个参数 def 是VNode类型，则会替换成 def.data.hook。mergeVNodeHook 的功能是：如果def[hookKey] 不存在，则直接调用hook，如果存在则将hook合并存储起来，在后续合适时机调用。<br/>
&emsp;&emsp;由代码可以看出，对指令 inserted 钩子函数的处理是：若VNode是新创建的，则会把 dirsWithInsert 数组中的函数追加到 vnode.data.hook.insert 中执行。如果是更新VNode，则直接执行钩子函数。<br/>
&emsp;&emsp;对指令 componentUpdated 钩子函数的处理是：使用 mergeVNodeHook 函数进行处理，等待后面子组件全部更新完成后调用。<br/>
```js
function _update (oldVnode, vnode) {
  /* 省略... */
  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}
```
&emsp;&emsp;_update 函数的最后是对 unbind 钩子函数的处理，在旧VNode存在而新VNode不存在时，即指令与元素解绑时调用 unbind 钩子函数。<br/>
## 二、v-bind
&emsp;&emsp;使用 v-bind 指令可以动态地绑定一个或多个特性，或一个组件 prop 到表达式，v-bind 指令可以简写为 **：**。<br/>
&emsp;&emsp;<br/>
```html
<body>
  <div id="app"></div>
</body>
<script>
  let vm = new Vue({
    el: '#app',
    template: `<div>
        <div v-bind:id="id"
           :class="{ red: isRed }"
           :style="{ fontSize: size + 'px' }"
        >666</div>
      </div>`,
    data () {
      return {
        id: 123,
        size: 24,
        isRed: true
      }
    }
  })
</script>
```
&emsp;&emsp;<br/>
```js
ast = {
  tag: "div",
  children: [
    {
      tag: "div",
      hasBindings: true,
      attrs: [{/* 省略属性id详情 */}],
      attrsList: [{/* 省略属性id详情 */}],
      attrsMap: {
        :class: "{ red: isRed }",
        :style: "{ fontSize: size + 'px' }",
        v-bind:id: "id"
      },
      rawAttrsMap: {
        /* 省略属性v-bind:id、:class、:style详情 */
      }
      styleBinding: "{ fontSize: size + 'px' }",
      classBinding: "{ red: isRed }"
      /* 省略其它属性... */
    }
  ]
  /* 省略其它属性... */
}
```
&emsp;&emsp;<br/>
```js
_c(
  'div',
  [
    _c(
      'div',
      {
        class:{ red: isRed },
        style:({ fontSize: size + 'px' }),
        attrs:{"id":id}
      },
      [_v("666")]
    )
  ]
)
```
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
```js
vnode = {
  tag: "div",
  children: [
    {
      tag: "div",
      data: {
        attrs: {id: 123}
        class: {red: true}
        style: {fontSize: "24px"}
      }
      /* 省略其它属性... */
    }
  ]
  /* 省略其它属性... */
}
```
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 三、v-on
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 四、v-for
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 五、v-if、v-else
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 六、v-model
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 七、v-show
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 八、总结
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
