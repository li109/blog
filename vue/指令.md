# Vue2.0源码阅读笔记（十）：指令
&emsp;&emsp;指令是带有 v- 前缀的特殊特性，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。<br/>
&emsp;&emsp;Vue2.0 内置了形如v-bind、v-on等指令，如果需要对普通 DOM 元素进行底层操作还可以使用自定义指令。<br/>
## 一、自定义指令
&emsp;&emsp;在Vue2.0 中，可以通过自定义指令对普通 DOM 元素进行底层操作。一个指令定义对象可以提供如下几个钩子函数：<br/>
> 1、bind：指令第一次绑定到元素时调用，只调用一次。<br/>
> 2、inserted：被绑定元素插入父节点时调用。<br/>
> 3、update：所在组件的VNode更新时调用。<br/>
> 4、componentUpdated：指令所在组件的VNode及其子VNode全部更新够调用。<br/>
> 5、unbind：指令与元素解绑时调用，只调用一次。<br/>

&emsp;&emsp;通过如下示例来阐述源码中对自定义指令的处理过程：<br/>
```html
<body>
  <div id="app"></div>
</body>
<script>
  let vm = new Vue({
    el: '#app',
    template: '<div>' +
      '<input v-focus>' +
      '</div>',
    directives: {
      focus: {
        inserted: function (el) {
          el.focus()
        }
      }
    }
  })
</script>
```
### 1、全局注册与局部注册
&emsp;&emsp;**指令**、**组件**和**过滤器**在Vue中称为**资源**。可以通过全局API进行全局注册，也可以通过具体选项进行局部注册。组件的全局注册和组件注册在[《组件》](https://juejin.im/post/5da42eb16fb9a04dfd267369)一文中详细阐述过，指令的处理与之类似，这里简要说明。<br/>
&emsp;&emsp;自定义指令全局注册的方法如下所示：<br/>
```js
Vue.directive = function (id, definition) {
  if (!definition) {
    return this.options.directives[id]
  } else {
    if (typeof definition === 'function') {
      definition = { bind: definition, update: definition };
    }
    Vue.options.directives[id] = definition;
    return definition
  }
}
```
&emsp;&emsp;Vue.directive 方法功能比较简单：将自定义指令的名字与配置对象转化成 Vue.options.directives 对象上的键值对。当配置对象为函数时，将该函数当成 bind 与 update 的钩子函数内容来处理，这是因为Vue提供了这种函数简写的方式，在[《选项合并》](https://juejin.im/post/5c8f60f8e51d45768a6e95f0)中有过详细阐述。<br/>
&emsp;&emsp;使用 directives 选项来注册指令，会将自定义指令信息存储在当前组件实例的 $options.directives 对象上。<br/>
### 2、模板编译
&emsp;&emsp;带有自定义指令的标签在生成AST时，会调用 processElement 函数对自定义指令进行处理。<br/>
```js
function processElement (element,options) {
  /* ... */
  processAttrs(element);
  return element
}
```
&emsp;&emsp;processElement 函数会将标签上的属性解析到元素对象的 attrsList 与 attrsMap 属性中，然后调用 processAttrs 函数处理标签上的属性。如果有指令属性，则将其放入到元素对象的 directives 数组属性中。<br/>
&emsp;&emsp;模板编译的 codegen 阶段，在执行 genData 时会根据 el.directives 将指令信息存入到 el.data 字符串中。<br/>
&emsp;&emsp;渲染函数最终根据标签名称el.tag、标签数据el.data、子节点children共同生成。实例中的模板经过编译后生成的渲染函数如下所示：<br/>
```js
_c(
  'div',
  [
    _c(
      'input',
      {
        directives:[
          {
            name:"focus",
            rawName:"v-focus"
          }
        ]
      }
    )
  ]
)
```
### 3、生成VNode
&emsp;&emsp;调用 Vue.prototype._render 方法生成VNode，本质是通过调用渲染函数来完成的。渲染函数中的 _c() 是 createElement 的别称，在函数内部通过调用 _createElement 函数来生成VNode。<br/>
```js
function _createElement (context,tag,data,children,normalizationType){
  /* ... */
  if (config.isReservedTag(tag)) {
    vnode = new VNode(
      config.parsePlatformTagName(tag), data, children,undefined, undefined, context
    );
  }
  /* ... */    
}
```
&emsp;&emsp;根据示例的渲染函数生成的VNode如下所示：<br/>
```js
vnode = {
  tag: "div",
  children: [
    {
      tag: "input",
      data: {
        directives: [
          {
            name: "focus",
            rawName: "v-focus"
          }
        ]
      }
      /* 省略其它属性 */
    }
  ]
  /* 省略其它属性 */
}
```
### 4、patch
&emsp;&emsp;在 patch 过程中，会调用 createElm 函数来生成真实DOM并插入到DOM树中。<br/>
```js
function createElm (/* ... */){
    /* 省略... */
    createChildren(vnode, children, insertedVnodeQueue);
    if (isDef(data)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
    }
    insert(parentElm, vnode.elm, refElm);
    /* 省略... */
}

function invokeCreateHooks (vnode, insertedVnodeQueue) {
  for (var i = 0; i < cbs.create.length; ++i) {
    cbs.create[i](emptyNode, vnode);
  }
  i = vnode.data.hook;
  if (isDef(i)) {
    if (isDef(i.create)) { i.create(emptyNode, vnode); }
    if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
  }
}
```
&emsp;&emsp;关于 cbs 中各阶段的钩子函数的详细阐述可参看[《Virtual DOM》](https://juejin.im/post/5d536743e51d456205410382#heading-13)。<br/>
```js
cbs = {
  create: [
    /* 省略... */
    function updateDirectives (oldVnode, vnode) {/*省略具体代码*/}
  ]
  /* 省略... */
}
```
&emsp;&emsp;在 updateDirectives 方法中，如果虚拟DOM的 data.directives 属性存在，会调用内部方法 _update 。该方法比较很重要，自定义指令提供的钩子都在该函数中进行处理，下面分步详细解读该函数：<br/>
```js
function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  /* 省略... */
}
```
&emsp;&emsp;函数首先定义一些变量，变量的具体含义如下所示：<br/>
> isCreate：指令所在的元素节点是否被创建。<br/>
> isDestroy：指令所在的元素节点是否被销毁。<br/>
> oldDirs：旧元素节点上的指令。<br/>
> newDirs：新元素节点上的指令。<br/>
> dirsWithInsert：拥有 inserted 钩子函数的指令。<br/>
> dirsWithPostpatch：拥有 componentUpdated 钩子函数的指令。<br/>

&emsp;&emsp;在 _update 函数中，会调用 callHook 来调用具体的钩子函数。<br/>
```js
function callHook (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}
```
&emsp;&emsp;接着说 _update 函数，在定义变量之后处理新VNode存在的情况。代码如下所示：<br/>
```js
function _update (oldVnode, vnode) {
  /* 省略... */
  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      callHook(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }
  /* 省略... */
}
```
&emsp;&emsp;当新VNode存在而旧VNode不存在时，说明新VNode是新创建的，未与自定义指令绑定，此时第一次绑定调用 bind 钩子函数，若有 inserted 钩子函数，则将指令存入 dirsWithInsert 数组。<br/>
&emsp;&emsp;当新VNode和旧VNode都存在时，说明是在进行VNode更新。此时调用 update 钩子函数，若有 componentUpdated 钩子函数，则将指令存入 dirsWithPostpatch 数组。<br/>
&emsp;&emsp;然后是对 inserted 与 componentUpdated 钩子函数的处理：<br/>
```js
function _update (oldVnode, vnode) {
  /* 省略... */
  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
       mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }
  /* 省略... */
}
```
&emsp;&emsp;mergeVNodeHook 函数接收三个参数：def、 hookKey、hook。如果第一个参数 def 是VNode类型，则会替换成 def.data.hook。mergeVNodeHook 的功能是：如果def[hookKey] 不存在，则直接调用hook，如果存在则将hook合并存储起来，在后续合适时机调用。<br/>
&emsp;&emsp;由代码可以看出，对指令 inserted 钩子函数的处理是：若VNode是新创建的，则会把 dirsWithInsert 数组中的函数追加到 vnode.data.hook.insert 中执行。如果是更新VNode，则直接执行钩子函数。<br/>
&emsp;&emsp;对指令 componentUpdated 钩子函数的处理是：使用 mergeVNodeHook 函数进行处理，等待后面子组件全部更新完成后调用。<br/>
```js
function _update (oldVnode, vnode) {
  /* 省略... */
  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}
```
&emsp;&emsp;_update 函数的最后是对 unbind 钩子函数的处理，在旧VNode存在而新VNode不存在时，即指令与元素解绑时调用 unbind 钩子函数。<br/>
## 二、v-bind
&emsp;&emsp;使用 v-bind 指令可以动态地绑定一个或多个特性，或一个组件 prop 到表达式，v-bind 指令可以简写为 **：**。因为字符串拼接麻烦且易错，在将 v-bind 用于 class 和 style 时，Vue 做了专门的增强。所以 v-bind 指令的使用分为三种情况：普通属性、class、style。<br/>
&emsp;&emsp;有示例代码如下所示：<br/>
```html
<body>
  <div id="app"></div>
</body>
<script>
  let vm = new Vue({
    el: '#app',
    template: `<div>
        <div v-bind:id="id"
           :class="{ red: isRed }"
           :style="{ fontSize: size + 'px' }"
        >666</div>
      </div>`,
    data () {
      return {
        id: 123,
        size: 24,
        isRed: true
      }
    }
  })
</script>
```
&emsp;&emsp;在模板编译的 parse 阶段会调用 processElement 函数，在该函数的最后分别调用 transforms 数组中的函数来解析 v-bind 绑定的 class 和 style，最后用 processAttrs 函数来解析 v-bind 绑定的普通属性。<br/>
```js
function processElement (element,options) {
    /* 省略... */
    for (var i = 0; i < transforms.length; i++) {
      element = transforms[i](element, options) || element;
    }
    processAttrs(element);
    return element
}

transforms = [
  function transformNode (el, options) {
    /* ... */
    if(staticClass){el.staticClass=JSON.stringify(staticClass);}
    var classBinding = getBindingAttr(el, 'class', false);
    if(classBinding){el.classBinding = classBinding;}
  },
  function transformNode (el, options) {
    /* ... */
    var styleBinding = getBindingAttr(el, 'style', false);
    if (styleBinding) {el.styleBinding = styleBinding;}
  }
]
```
&emsp;&emsp;经过 processElement 函数处理后，v-bind 绑定的普通属性会存入元素节点的 attrs 属性中，class 与 style 会分别存入 classBinding 与 styleBinding 中。<br/>
```js
ast = {
  tag: "div",
  children: [
    {
      tag: "div",
      hasBindings: true,
      attrs: [{/* 省略属性id详情 */}],
      attrsList: [{/* 省略属性id详情 */}],
      attrsMap: {
        :class: "{ red: isRed }",
        :style: "{ fontSize: size + 'px' }",
        v-bind:id: "id"
      },
      rawAttrsMap: {
        /* 省略属性v-bind:id、:class、:style详情 */
      }
      styleBinding: "{ fontSize: size + 'px' }",
      classBinding: "{ red: isRed }"
      /* 省略其它属性... */
    }
  ]
  /* 省略其它属性... */
}
```
&emsp;&emsp;在模板编译的 codegen 阶段会调用 genElement 函数，并在该函数中调用 genData 函数来将 v-bind 绑定的普通属性、class 与 style 合并到 data 中。示例最终生成的渲染函数如下所示：<br/>
```js
_c(
  'div',
  [
    _c(
      'div',
      {
        class:{ red: isRed },
        style:({ fontSize: size + 'px' }),
        attrs:{"id":id}
      },
      [_v("666")]
    )
  ]
)
```
&emsp;&emsp;渲染函数经过 Vue.prototype._render 函数处理后生成 VNode，\_c() 函数的第二个参数会处理成元素标签 VNode 的 data 属性。<br/>
```js
vnode = {
  tag: "div",
  children: [
    {
      tag: "div",
      data: {
        attrs: {id: 123}
        class: {red: true}
        style: {fontSize: "24px"}
      }
      /* 省略其它属性... */
    }
  ]
  /* 省略其它属性... */
}
```
&emsp;&emsp;在 patch 阶段，会的调用 createElm 函数生成真实 DOM，在createElm 函数中生成真实 DOM 后会调用 invokeCreateHooks 来对 data 中的数据进行处理。<br/>
```js
function createElm (/*...*/){
  /*...*/
  var data = vnode.data;
  if (isDef(data)) {
    invokeCreateHooks(vnode, insertedVnodeQueue);
  }
  /*...*/
}

function invokeCreateHooks (vnode, insertedVnodeQueue) {
  for (var i = 0; i < cbs.create.length; ++i) {
    cbs.create[i](emptyNode, vnode);
  }
  i = vnode.data.hook;
  if (isDef(i)) {
    if(isDef(i.create)){i.create(emptyNode, vnode);}
    if(isDef(i.insert)){insertedVnodeQueue.push(vnode);}
  }
}
```
&emsp;&emsp;关于 cbs 的具体组成可以查看[《Virtual DOM》](https://juejin.im/post/5d536743e51d456205410382#heading-10) 一文，跟 v-bind 相关的部分如下所示：<br/>
```js
cbs = {
  create: [
    function updateAttrs (oldVnode, vnode) {/*省略具体代码*/},
    function updateClass (oldVnode, vnode) {/*省略具体代码*/},
    function updateStyle (oldVnode, vnode) {/*省略具体代码*/},
    /*
      updateDOMProps函数作用是更新一些特殊的属性：
      不能通过 setAttribute 设置，
      而是应该直接通过 DOM 元素设置的属性。
      比如：value、checked等
    */
    function updateDOMProps (oldVnode, vnode) {/*省略具体代码*/},
    /* 省略其它函数 */
  ]
  /* 省略其它属性 */
```
&emsp;&emsp; 使用 v-bind 指令修饰符 .prop 绑定的属性会放入 vnode.data.domProps 中，使用 updateDOMProps 进行处理，这里省略具体处理逻辑。 <br/>
&emsp;&emsp; 对普通属性的处理函数 updateAttrs 逻辑比较简单：对比新旧VNode，来决定增加还是删除属性，增加属性调用原生DOM的 setAttribute 方法，删除属性调用原生DOM的 removeAttribute 方法。在该函数中有对 IE 的兼容处理。<br/>
```js
function updateAttrs (oldVnode, vnode) {
  /* 省略... */
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
  /* 省略... */
}
```
&emsp;&emsp;对 class 处理的函数 updateClass 逻辑是：将Vue中使用的静态类staticClass 与使用响应式数据相关的 dynamicClass 统一起来，然后和普通属性一样调用 DOM 原生方法 setAttribute 添加类名。<br/>
```js
function updateClass (oldVnode, vnode) {
  /* 省略.... */
  var cls = genClassForVnode(vnode);
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}
```
&emsp;&emsp;对 style 处理的函数 updateStyle 有一点比较特殊，设置 style 属性时是调用 dom.style.setProperty 方法。<br/>
&emsp;&emsp;v-bind 指令中还有一点需要注意：可以添加 .sync 修饰符对一个 prop 进行“双向绑定”。.sync 修饰符实质上是语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器，v-on 指令将在下一节详细介绍。<br/>
```js
// 语法糖
<Child v-bind:val.sync = parentVal></Child>

// 相当于下面代码
<Child v-bind:val = parentVal
       @updateVal = "parentVal.a=$event">
</Child>
```
## 三、v-on
&emsp;&emsp;在 Vue 中用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。因为事件指令使用较多，Vue提供了简写形式：@。<br/>
&emsp;&emsp;有示例代码如下所示：<br/>
```html
<body>
    <div id="app"></div>
</body>
<script>
  let Child = {
  template: `<div @click="changeVal">点击</div>`,
  props: ['val'],
  methods: {
    changeVal () {
      this.$emit('updateVal', ++this.val.a)
    }
  }
}

let vm = new Vue({
  el: '#app',
  template: `<div>
      <Child v-bind:val = parentVal
            @updateVal = "parentVal.a=$event"
      ></Child>
      <div v-on:mouseover = "showMsg"
           @mouseout.stop = "hideMsg">
           {{parentVal.a}}
      </div>
      <div>{{message}}</div>
    </div>`,
  data() {
    return {
      parentVal: { a: 1 },
      message: '离开'
    }
  },
  methods: {
    showMsg () { this.message = '进入' },
    hideMsg () { this.message = '离开' },
  },
  components: { Child }
})
</script>
```
&emsp;&emsp;<br/>
```js
ast = {
  tag: "div",
  children: [
    {
      tag: "Child",
      attrs: {
        name: "val",
        value: "parentVal"
        /* 省略其它属性 */
      },
      events: {
        updateVal: {
          value: "parentVal.a=$event"
          /* 省略其它属性 */
        }
      }
    },
    {
      tag: "div",
      events: {
        mouseout: {
          value: "hideMsg"
          modifiers: {stop: true}
          /* 省略其它属性 */
        },
        mouseover: {
          value: "showMsg"
          /* 省略其它属性 */
        }
      }
    }
    /* 省略其它子节点 */
  ]
  /* 省略其它属性 */
}
```
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
```js
_c(
  'div',
  [
    _c(
      'Child',
      {
        attrs:{"val":parentVal},
        on:{
          "updateVal":function($event){
            parentVal.a=$event
          }
        }
      }
    ),
    _c(
      'div',
      {
        on:{
          "mouseover":showMsg,
          "mouseout":function($event){
            $event.stopPropagation();return hideMsg($event)
          }
        }
      },
      /* 省略子节点渲染函数 */
    )
    /* 省略其它子节点渲染函数 */
  ],
  1
)
```
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
```js

```
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 四、v-for
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 五、v-if、v-else
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 六、v-model
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 七、v-show
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 八、总结
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
