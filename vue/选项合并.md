# Vue2.0源码阅读笔记（一）：选项合并
&emsp;&emsp;Vue本质是上来说是一个函数，在其通过new关键字构造调用时，会完成一系列初始化过程。通过Vue框架进行开发，基本上是通过向Vue函数中传入不同的参数选项来完成的。参数选项往往需要加以合并，主要有两种情况：1、Vue函数本身拥有一些静态属性，在实例化时开发者会传入同名的属性；2、在使用继承的方式使用Vue时，需要将父类和子类上同名属性加以合并；<br/>
&emsp;&emsp;Vue函数定义在 */src/core/instance/index.js*中。<br/>
```js
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue)
```
&emsp;&emsp;在Vue实例化时会将选项集 *options* 传入到实例原型上的 *_init* 方法中加以初始化。initMixin函数的作用就是向Vue实例的原型对象上添加 *_init* 方法， *initMixin* 函数在 */src/core/instance/init.js* 中定义。<br/>
&emsp;&emsp;在 *_init* 函数中，会对传入的选项集进行合并处理。<br/>
```js
// merge options
if (options && options._isComponent) {
    initInternalComponent(vm, options)
} else {
    vm.$options = mergeOptions(
    resolveConstructorOptions(vm.constructor),
    options || {},
    vm
    )
}
```
&emsp;&emsp;在开发过程中基本不会传入 *_isComponent* 选项，因此在实例化时走 *else* 分支。通过 *mergeOptions* 函数来返回合并处理之后的选项并将其赋值给实例的 *$options* 属性。 *mergeOptions* 函数接收三个参数，其中第一个参数是将生成实例的构造函数传入 *resolveConstructorOptions* 函数中处理之后的返回值。<br/>
```js
export function resolveConstructorOptions (Ctor: Class<Component>) {
  let options = Ctor.options
  if (Ctor.super) {
    const superOptions = resolveConstructorOptions(Ctor.super)
    const cachedSuperOptions = Ctor.superOptions
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions
      // check if there are any late-modified/attached options (#4976)
      const modifiedOptions = resolveModifiedOptions(Ctor)
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions)
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) {
        options.components[options.name] = Ctor
      }
    }
  }
  return options
}
```
&emsp;&emsp;*resolveConstructorOptions* 函数的参数为实例的构造函数，在构造函数的没有父类时，简单的返回构造函数的 *options* 属性。反之，则走 *if* 分支，合并处理构造函数及其父类的 *options* 属性，如若构造函数的父类仍存在父类则递归调用该方法，最终返回唯一的 *options* 属性。在研究实例化合并选项时，为行文方便，将该函数返回的值统一称为选项合并的**父选项集合**，实例化时传入的选项集合称为**子选项集合**。<br/>
### 一、Vue函数上的静态属性options
&emsp;&emsp;在合并选项时，在没有继承关系存在的情况，传入的第一个参数为Vue函数上的静态属性 *options* ，那么这个静态属性到底包含什么呢？为了弄清楚这个问题，首先要搞清楚运行 *npm run dev* 命令来生成 */dist/vue.js* 文件的过程中发生了什么。<br/>
&emsp;&emsp;在 *package.json* 文件中 *scripts* 对象中有：
```js
"dev": "rollup -w -c scripts/config.js --environment TARGET:web-full-dev",
```
&emsp;&emsp;在使用rollup打包时，依据 *scripts/config.js* 中的配置，并将 *web-full-dev* 作为环境变量TARGET的值。<br/>
```js
// Runtime+compiler development build (Browser)
'web-full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
},
```
&emsp;&emsp;上述文件路径是在 *scripts/alias.js* 文件中配置过别名的。由此可知，执行 *npm run dev* 命令时，入口文件为 *src/platforms/web/entry-runtime-with-compiler.js* ，生成符合 *umd* 规范的 *vue.js* 文件。依照该入口文件对Vue函数的引用，按图索骥，逐步找到Vue构造函数所在的文件。如下图所示：<br/>
![Vue构造函数引用图](../image/vue/options-1.jpg)