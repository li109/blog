# Vue2.0源码阅读笔记（十二）：生命周期
&emsp;&emsp;在 Vue 中，除函数式组件外，所有组件都是 Vue 实例。每个 Vue 实例在被创建时都要经过一系列的初始化过程：数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。<br/>
&emsp;&emsp;在生成 Vue 实例的过程中会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。本文从源码的角度来详细阐述组件生命周期的相关内容。<br/>
## 一、钩子函数的调用
&emsp;&emsp;生命周期钩子函数调用是通过 callHook 函数完成的，callHook 函数主要包含三个方面的内容。<br/>
```js
function callHook (vm, hook) {
  pushTarget()
  const handlers = vm.$options[hook]
  const info = `${hook} hook`
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info)
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook)
  }
  popTarget()
}
```
### 1、调用钩子函数
&emsp;&emsp;在生成 Vue 实例的过程中会调用 mergeOptions 函数对选项进行处理，生命周期钩子函数经过合并处理后会添加到实例对象的 $options 属性上，合并后各生命周期函数存储在对应的数组中。具体细节可参看文章[《选项合并》](https://juejin.im/post/5c8f60f8e51d45768a6e95f0#heading-0)。<br/>
&emsp;&emsp;callHook 函数调用的形式如下所示：<br/>
```js
// 调用 created 生命周期钩子函数
callHook(vm, 'created')
```
&emsp;&emsp;此时 callHook 函数会循环遍历执行 vm.$options.created 数组中的函数，以完成 created 生命周期钩子函数的调用。<br/>
### 2、防止收集冗余依赖
&emsp;&emsp;在函数首尾有如下代码：<br/>
```js
function callHook (vm, hook) {
  pushTarget()
  /* 省略... */
  popTarget()
}
```
&emsp;&emsp;这两个函数的源码如下所示：<br/>
```js
Dep.target = null
const targetStack = []

function pushTarget (target) {
  targetStack.push(target)
  Dep.target = target
}

function popTarget () {
  targetStack.pop()
  Dep.target = targetStack[targetStack.length - 1]
}
```
&emsp;&emsp;Vue 实例的当前观察者对象是唯一的，所谓当前观察者对象是指即将要收集依赖的目标，pushTarget 函数将观察者对象入栈而不是简单的赋值，是为了在当前观察者对象操作完成后恢复成之前的观察者对象。<br/>
&emsp;&emsp;在函数的首尾调用 pushTarget() 和 popTarget() 函数，是为了防止在生命周期钩子函数中使用 props 数据时收集冗余的依赖。具体详情可参看[《响应式原理》](https://juejin.im/post/5cb6ee28f265da03474df961#heading-10)。<br/>
### 3、hookEvent
&emsp;&emsp;在 callHook 函数中还有一部分代码：<br/>
```js
if (vm._hasHookEvent) {
  vm.$emit('hook:' + hook)
}
```
&emsp;&emsp;这行代码比较有意思，也就是说在执行生命周期钩子函数时，如果 vm._hasHookEvent 的值为 true，则会额外触发一个形如 hook:created 的事件。<br/>
&emsp;&emsp;那么什么时候实例的 _hasHookEvent 属性值为真呢？还记得在上篇文章讲解 $on 方式时有提过这点：<br/>
```js
const hookRE = /^hook:/
Vue.prototype.$on = function(event, fn){
  /* 省略... */
  if (hookRE.test(event)) {
    vm._hasHookEvent = true
  }
  /* 省略... */
}
```
&emsp;&emsp;上篇文章同时讲到，在组件上使用自定义指令最终会转化成调用 $on 的形式，也就是说按照以下使用就能命中这种情况：<br/>
```js
<Child @hook:created = "doSomething"></Child>
```
&emsp;&emsp;这种形式的事件称为 hookEvent，在官方文档上没有找到 hookEvent 的说明，但是在 Vue 源码中有实现。所谓 hookEvent 就是特殊命名的事件—— hook: + 生命周期名称。这种事件会在子组件对应生命周期钩子函数调用时被调用。<br/>
&emsp;&emsp;那 hookEvent 有什么用呢？其实在使用第三方组件的时候能够用到，使用 hookEvent 可以在不破坏第三方组件代码的前提下，向其注入生命周期函数。<br/>
## 二、组件的生命周期
&emsp;&emsp;关于组件实例的生命周期，官网上面有一张很经典的图片：<br/>
![生命周期](../image/vue/lifecycle.png)
&emsp;&emsp;这张图片包含的信息较多，下面我们通过拆解这张图片来逐步讲解组件实例的生命周期。<br/>
### 1、beforeCreate和created
![生命周期](../image/vue/lifecycle_01.png)
&emsp;&emsp;Vue 的构造函数主要包含 \_init 方法，在组件实例化的过程中会通过该函数完成一系列初始化操作。<br/>
```js
function Vue (options) {
  /* 省略警告信息 */
  this._init(options)
}
```
&emsp;&emsp;\_init 方法首先进行合并选项，然后初始化生命周期、事件等，最后挂载DOM元素。代码如下所示：<br/>
```js
Vue.prototype._init = function (options) {
  const vm = this
  /*...*/
  if (options && options._isComponent) {
    initInternalComponent(vm, options)
  } else {
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }
  /*...*/
  initLifecycle(vm)
  initEvents(vm)
  initRender(vm)
  callHook(vm, 'beforeCreate')
  initInjections(vm)
  initState(vm)
  initProvide(vm)
  callHook(vm, 'created')
  /*...*/
  if (vm.$options.el) {
    vm.$mount(vm.$options.el)
  }
}
```
&emsp;&emsp;这里函数调用的**顺序**很重要，数据的处理都是在 beforeCreate 生命周期函数调用之后初始化的，也就是说在 beforeCreate 生命周期函数中，不能使用 props、methods、data、computed 和 watch 等数据，也不能使用 provide/inject 中的数据。一般从后端加载数据不用赋值给data中时，可以放在这个生命周期中。<br/>
&emsp;&emsp;在 beforeCreate 与 created 生命周期函数调用中间，调用初始化各个数据的函数。initState 函数代码如下所示：<br/>
```js
function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```
&emsp;&emsp;注意 initState 函数中函数的调用顺序：initProps——initData——initComputed——initWatch。这样初始化顺序的结果是在 data 选项中可以使用 props；在 computed 选项中可以使用 data、props 中的数据；watch 选项可以监听 data、props、computed 数据的变化。methods 选项的组成是函数，在函数调用时这些初始化工作已经完成，所以可以使用全部的数据。<br/>
&emsp;&emsp;初始化 inject 的 initInjections 函数在 initState 之前调用，最后调用初始化 provide 的 initProvide 函数。这样就决定了在 data、props、computed 等选项中可以使用 inject 中的数据，provide 选项中可以使用 data、props、computed、inject 等的数据。<br/>
&emsp;&emsp;调用 created 生命周期函数之前，数据初始化已经完成，在函数中可以操作这些数据。向后端请求的数据需要赋值给 data 时，可以放在 created 生命周期函数中。<br/>
### 2、beforeMount和mounted
![生命周期](../image/vue/lifecycle_02.png)
&emsp;&emsp;在 \_init 函数的最后执行 $mount 方法来完成DOM挂载，下面以**运行时+编译器**的版本来阐述具体挂载过程。<br/>
&emsp;&emsp;编译器相关代码如下所示：<br/>
```js
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (el,hydrating){
  el = el && query(el)
  /* 省略... */
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* 省略... */
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        /* 省略... */
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      /* 省略... */ 
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns
      /* 省略... */
    }
  }
  return mount.call(this, el, hydrating)
}
```
&emsp;&emsp;该函数的作用是将 template/el 转化成渲染函数，具体的转化过程可参看[《模板编译》](https://juejin.im/post/5d4135336fb9a06b160f094d)一文。<br/>
&emsp;&emsp;根据渲染函数完成挂载的代码如下所示：<br/>
```js
Vue.prototype.$mount = function (el,hydrating){
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

function mountComponent (vm,el,hydrating){
  vm.$el = el
  /* 省略渲染函数不存在的警告信息 */
  callHook(vm, 'beforeMount')

  let updateComponent
  /* 删除性能埋点相关 */
  updateComponent = () => {
    vm._update(vm._render(), hydrating)
  }

  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```
&emsp;&emsp;可以看到 beforeMount 生命周期是在渲染函数生成之后、开始执行挂载之前调用的。<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
### 3、beforeUpdate和updated
&emsp;&emsp;<br/>
![生命周期](../image/vue/lifecycle_03.png)
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
### 4、beforeDestroy和destroyed
&emsp;&emsp;<br/>
![生命周期](../image/vue/lifecycle_04.png)
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 三、keep-alive组件
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 四、捕获子孙组件错误
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 五、总结
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>