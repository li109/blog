# Vue2.0源码阅读笔记（九）：内置组件
&emsp;&emsp;Vue2.0中一共有五个内置组件：动态渲染组件的component、用于过渡动画的transition-group与transition、缓存组件的keep-alive、内容分发插槽的slot。<br/>
&emsp;&emsp;component组件配合is属性在编译的过程中被替换成具体的组件，而slot组件已经在上一篇文章中加以描述，因此本章主要阐述剩余的三个内置组件。<br/>
## 一、KeepAlive
&emsp;&emsp;\<keep-alive\> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。\<keep-alive\> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。该组件要求同时只有一个子元素被渲染。
### 1、KeepAlive组件
&emsp;&emsp;KeepAlive 组件源码如下所示：<br/>
```js
{
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created () {
    this.cache = Object.create(null)
    this.keys = []
  },

  destroyed () {
    for (const key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys)
    }
  },

  mounted () {
    this.$watch('include', val => {
      pruneCache(this, name => matches(val, name))
    })
    this.$watch('exclude', val => {
      pruneCache(this, name => !matches(val, name))
    })
  },

  render () {
    const slot = this.$slots.default
    const vnode: VNode = getFirstComponentChild(slot)
    const componentOptions: ?VNodeComponentOptions = vnode && vnode.componentOptions
    if (componentOptions) {
      const name: ?string = getComponentName(componentOptions)
      const { include, exclude } = this
      if (
        (include && (!name || !matches(include, name))) ||
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      const { cache, keys } = this
      const key: ?string = vnode.key == null
        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')
        : vnode.key
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance
        remove(keys, key)
        keys.push(key)
      } else {
        cache[key] = vnode
        keys.push(key)
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode)
        }
      }

      vnode.data.keepAlive = true
    }
    return vnode || (slot && slot[0])
  }
}
```
&emsp;&emsp;KeepAlive 组件的逻辑相对比较简单，根据传入的 include 与 exclude 规则来决定是否缓存子组件，根据传入的 max 参数来决定最多缓存多少组件。<br/>
&emsp;&emsp;从 render 函数中可以看出，如果子组件是缓存对象 cache 的属性，则直接返回该子组件的VNode，如果不是，则添加到缓存对象上，并将缓存的VNode的 data.keepAlive 属性置为 true。<br/>
&emsp;&emsp;这里有两点需要注意：keepAlive组件的 abstract 属性为 true、被缓存的子组件 vnode.data.keepAlive 属性为 true。<br/>
### 2、abstract 属性
&emsp;&emsp;当 abstract 属性为 true 时，表示该组件为抽象组件：组件本身不会被渲染成DOM元素、不会出现在父组件链中。<br/>
&emsp;&emsp;在完成一系列初始化的过程中，会调用 initLifecycle 方法：<br/>
```js
function initLifecycle(vm) {
  const options = vm.$options

  let parent = options.parent
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }
  /* ... */
}
```
&emsp;&emsp;由上可知，在 options.abstract 为 true 时，组件实例建立父子关系的时候会被忽略。<br/>
### 3、vnode.data.keepAlive 属性
&emsp;&emsp;在 patch 的过程中会调用 createComponent 方法：<br/>
```js
function createComponent(vnode,insertedVnodeQueue,parentElm,refElm){
  let i = vnode.data
  if (isDef(i)) {
    const isReactivated = isDef(vnode.componentInstance) && i.keepAlive
    if (isDef(i = i.hook) && isDef(i = i.init)) {
      i(vnode, false)
    }
    if (isDef(vnode.componentInstance)) {
      initComponent(vnode, insertedVnodeQueue)
      insert(parentElm, vnode.elm, refElm)
      if (isTrue(isReactivated)) {
        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
      }
      return true
    }
  }
}
```
&emsp;&emsp;在本系列第七篇文章[《组件》](https://juejin.im/post/5da42eb16fb9a04dfd267369#heading-14)中，详细分析过 createComponent 方法，当时没考虑 keepAlive 值为 true的情况，在这里重点介绍。<br/>
&emsp;&emsp;在首次渲染时 vnode.componentInstance 的值为空，因此不论 keepAlive 是否为空，isReactivated 值总是 false。再次渲染时，若 keepAlive 值为 true 则isReactivated 为true。<br/>
```js
if (isDef(i = i.hook) && isDef(i = i.init)) {
  i(vnode, false)
}
```
&emsp;&emsp;钩子函数 init 在 keepAlive 值为 false 时的功能是调取组件的构造函数生成组件构造实例。<br/>
```js
init (vnode, hydrating) {
  if (
    vnode.componentInstance &&
    !vnode.componentInstance._isDestroyed &&
    vnode.data.keepAlive
  ) {
    const mountedNode = vnode
    componentVNodeHooks.prepatch(mountedNode, mountedNode)
  } else {
    /* 省略... */
  }
}
```
&emsp;&emsp;当 keepAlive 值为 true 时，会调用 prepatch 方法，该方法不会再执行组件的 mount 过程，而是直接调用 updateChildComponent 方法更新子组件，这也是被 keepAlive 包裹的组件在有缓存的时候就不会在执行组件的 created、mounted 等钩子函数的原因。<br/>
```js
function prepatch (oldVnode, vnode) {
  var options = vnode.componentOptions;
  var child = vnode.componentInstance = oldVnode.componentInstance;
  updateChildComponent(child,options.propsData,options.listeners,
        vnode,options.children);
}
```
&emsp;&emsp;在 createComponent 函数最后，如果组件再次渲染且 keepAlive 为 true 时，会调用 reactivateComponent 函数，该函数将缓存的DOM元素直接插入到目标位置。<br/>
```js
function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  /* 省略对 transition 动画不触发的问题的处理*/
  insert(parentElm, vnode.elm, refElm);
}
```
## 二、Transition
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 三、TransitionGroup
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
## 四、总结
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>