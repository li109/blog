# JavaScript夯实基础系列（一）：词法作用域
&emsp;&emsp;作用域是一组规则，规定了引擎如何通过标识符名称来查询一个变量。作用域模型有两种：**词法作用域**和**动态作用域**。词法作用域是在编写时就已经确定的：通过阅读包含变量定义的数行源码就能知道变量的作用域。JavaScript采用的是**词法作用域**，也称为**执行环境**。动态作用域不是在代码编写时静态决定的，而是在执行过程中被确定。JavaScript实际上没有动态作用域，但是*this*的用法有些像动态作用域。静态作用域关心函数在何处被声明，而动态作用域关心函数在何处被调用。
### 一、作用域链
&emsp;&emsp;在ES6之前，一般认为JavaScript只有全局作用域以及基于函数的作用域，没有块级作用域（有两种特殊情况：*with*以及*try/catch*中的*catch*块，*with*在严格模式下不能使用，基本已废弃，不推荐使用。*catch*的块级作用域性质不常用，可用来ES6块级作用域的Polyfill）。ES规范强制规定全局变量是全局对象的属性，但是对于局部变量没有类似的规定。局部变量基本是函数内的变量（没有使用*var*、*let*或者*const*声明的变量为全局变量）以及函数参数。一般认为，局部变量是一个跟所在函数关联的变量对象的属性。这个变量对象在ES3中叫**调用对象**，在ES5中叫**声明上下文对象**，该对象对我们是透明的，不可见。全局对象我们可以通过*this*关键字来引用。<br/>
&emsp;&emsp;当程序执行到函数中时，会产生一个跟该函数相关的作用域链，**作用域链**是一个对象列表或者链表。拿作用域链的链表实现来说，链表的尾结点是全局对象，嵌套函数的每一层函数对应链表上的一个节点，该节点包含两个指针，分别指向函数对应的变量对象和包含函数对应的节点。注意：每一个执行中得函数都有一个作用域链，包含函数与被包含函数并不是在同一个作用域链上。可以想象，当程序从包含函数流进被包含函数时，被包含函数的作用域链生成过程是：先复制包含函数的作用域链，然后生成一个节点该节点包含一个指向自身函数对应的变量对象，最后以**前插法**的方式将该节点插入到新生成链表的头部。所有链表的尾部节点都是指向全局对象<br/>
&emsp;&emsp;JavaScript在查找一个变量时，即**变量解析**，会从对应作用域链的头部开始查，如果在头部指针指向的变量对象中找到该变量，则停止查询，采用找到的该变量的值。如果没有找到，则沿着链表逐级查询，直到查询到链表尾部节点对应的变量对象，即**全局对象**，如果最终没有查询到变量，则会报*ReferenceError*的错误。<br/>
&emsp;&emsp;例如：下面代码的作用域链如下图所示。全局变量的作用域链只包含指向全局对象的指针；函数a的作用域链有两个节点，分别指向函数a对应的变量对象和全局对象；函数b的作用域链有三个节点，分别对应，指向b对应的变量对象、指向a对应的变量对象和全局对象。函数a不能访问函数b中的变量*test3*，因为在函数a的作用域链中并不包括函数b对应的变量对象。如果在函数a中使用*test3*，解析变量*test3*时，首先从a的作用域链头部开始，查询a对应的变量对象，然后查询全局对象，都没有找到，程序会提示引用错误。
```javaScript
var test1 = 'global' // 全局变量
a()

function a () {
    var test2 = 'a' // 函数a的局部变量
    console.log(test2)
    b()

    function b () {
        var test3 = 'b' // 函数b的局部变量
        console.log(test2 + test3)
    }
}
```
![作用域链](../image/js/scopeChain.png)
### 二、延长作用域链
&emsp;&emsp;JavaScript中有两种方式可以延长作用域链，ES3之前的*with*以及ES3添加的*try/catch*。程序执行到这两个语句时，会在作用域链的最前端添加一个指向新变量对象的节点，该变量对象会在程序执行完毕后被移除。<br/>
#### 1、with
&emsp;&emsp;当我们多次使用一个对象的属性时，每次都需要在需要调用的属性前加上对象，写法相对繁琐，使用*with*可以减少所写代码量。
```javaScript
function getUrl () {
    var obj = {}
    obj.a = location.hash
    obj.b = location.href
    return obj
}

// 使用 with 改写
function useWith () {
    var obj = {}
    with(location) {
        obj.a = hash
        obj.b = href
    }
    return obj
}
```
&emsp;&emsp;*with*会将指定的对象添加到作用域链中。值得注意的事，在查询变量的时候才会用到作用域链，创建新变量的时候不使用。因此在使用*with*时，有些时候会遇到一些奇怪的情况。如下代码所示：
```javaScript
function test(obj) {
    with (obj) {
        a = 2;
    }
}

var obj1 = { a: 3 };
var obj2 = { b: 3 };

test( obj1 );
console.log( obj1.a ); // 2

test( obj2 );
console.log( obj2.a ); // undefined
console.log( a ); // 2 ---全局作用域被泄漏了！
```
&emsp;&emsp;在函数*test*执行时，*with*语句延长了函数*test*的作用域链，对象*obj*将被添加到作用域链中。分别将*obj1*和*obj2*作为参数传递给函数时，JavaScript引擎会沿着作用域链查询变量。当参数是*obj1*时，引擎查找到其拥有该变量，因此给*obj1*的*a*属性复制为2。当参数是*obj2*时，引擎没有在*obj2*中找到该变量，接着在函数*test*的变量对象上查询，仍然没有找到该变量，最后在全局对象上查询。在都没有找到情况下，*a=2*语句分两步执行，首先创建一个新的全局变量*a*，然后从作用域链重新执行一遍查找，最终在全局对象上找到变量*a*，执行赋值操作，导致全局作用域被泄漏。<br/>
&emsp;&emsp;*with*语句在严格模式下不能使用，在非严格模式下也不提倡使用，该语句被废弃的原因主要是性能问题。JavaScript引擎在编译阶段会做很多性能优化的工作，优化的方法之一就是在词法分析的时候静态的分析代码，提前决定变量和函数声明在什么位置，执行的时候能够更快速。*with*语句可以添加指定对象到作用域链，JavaScript引擎没办法提前分析你会往这个作用域链的顶端放什么样的变量对象，因此在词法分析时通过分析代码来决定变量和函数声明位置的结果将被全部推翻，使得优化变的毫无意义，没有经过优化的代码肯定比优化过的代码慢。
#### 2、try/catch
&emsp;&emsp;*try/catch/finally*语句是JavaScript的异常处理机制。*try*从句定义了需要处理的异常所在的代码块，当*try*块代码出现异常时，调用*catch*块中的的代码。不论*try*块中的代码是否出现异常，*finally*块内的代码必定执行。
```javaScript
try {
    undefined(); // 用非法的操作强制产生一个异常！
}
catch (e) {
    e = 1
    console.log(e); // 1
}

console.log(e); // ReferenceError: `err` not found
```
&emsp;&emsp;*catch*块会创建一个新的变量对象，将变量对象添加到作用域链顶端。换而言之，*catch*块中定义的变量拥有块级作用域。上面代码显示的变量*e*只存在于*catch*块，在外部引用会报错。在IE8以及之前的版本中，*catch*块捕获的变量对象会添加到所在函数的变量对象上，如果不被函数包裹，则会添加到全局对象上。<br/>
&emsp;&emsp;*catch*块的块级作用域性质可以shim ES6中新添加的*let*和*const*等块级作用域，在章节末尾有详细讲解。
### 三、动态声明变量
### 四、块级作用域