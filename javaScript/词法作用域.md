# 词法作用域
&emsp;&emsp;作用域是一组规则，规定了引擎如何通过标识符名称来查询一个变量。作用域模型有两种：**词法作用域**和**动态作用域**。词法作用域是在编写时就已经确定的：通过阅读包含变量定义的数行源码就能知道变量的作用域。JavaScript采用的是**词法作用域**，也称为**执行环境**。动态作用域不是在代码编写时静态决定的，而是在执行过程中被确定。JavaScript实际上没有动态作用域，但是*this*的用法有些像动态作用域。静态作用域关心函数在何处被声明，而动态作用域关心函数在何处被调用。
### 一、作用域链
&emsp;&emsp;在ES6之前，一般认为JavaScript只有全局作用域以及基于函数的作用域，没有块级作用域（有两种特殊情况：*with*以及*try/catch*中的*catch*块，*with*在严格模式下不能使用，基本已废弃，不推荐使用。*catch*的块级作用域性质不常用，可用来ES6块级作用域的Polyfill）。ES规范强制规定全局变量是全局对象的属性，但是对于局部变量没有类似的规定。局部变量基本是函数内的变量（没有使用*var*、*let*或者*const*声明的变量为全局变量）以及函数参数。一般认为，局部变量是一个跟所在函数关联的变量对象的属性。这个变量对象在ES3中叫**调用对象**，在ES5中叫**声明上下文对象**，该对象对我们是透明的，不可见。全局对象我们可以通过*this*关键字来引用。<br/>
&emsp;&emsp;当程序执行到函数中时，会产生一个跟该函数相关的作用域链，**作用域链**是一个对象列表或者链表。拿作用域链的链表实现来说，链表的尾结点是全局对象，嵌套函数的每一层函数对应链表上的一个节点，该节点包含两个指针，分别指向函数对应的变量对象和包含函数对应的节点。注意：每一个执行中得函数都有一个作用域链，包含函数与被包含函数并不是在同一个作用域链上。可以想象，当程序从包含函数流进被包含函数时，被包含函数的作用域链生成过程是：先复制包含函数的作用域链，然后生成一个节点该节点包含一个指向自身函数对应的变量对象，最后以**前插法**的方式将该节点插入到新生成链表的头部。所有链表的尾部节点都是指向全局对象<br/>
&emsp;&emsp;JavaScript在查找一个变量时，即**变量解析**，会从对应作用域链的头部开始查，如果在头部指针指向的变量对象中找到该变量，则停止查询，采用找到的该变量的值。如果没有找到，则沿着链表逐级查询，直到查询到链表尾部节点对应的变量对象，即**全局对象**，如果最终没有查询到变量，则会报*ReferenceError*的错误。<br/>
&emsp;&emsp;例如：下面代码的作用域链如下图所示。全局变量的作用域链只包含指向全局对象的指针；函数a的作用域链有两个节点，分别指向函数a对应的变量对象和全局对象；函数b的作用域链有三个节点，分别对应，指向b对应的变量对象、指向a对应的变量对象和全局对象。函数a不能访问函数b中的变量*test3*，因为在函数a的作用域链中并不包括函数b对应的变量对象。如果在函数a中使用*test3*，解析变量*test3*时，首先从a的作用域链头部开始，查询a对应的变量对象，然后查询全局对象，都没有找到，程序会提示引用错误。
```javaScript
var test1 = 'global' // 全局变量
a()

function a () {
    var test2 = 'a' // 函数a的局部变量
    console.log(test2)
    b()

    function b () {
        var test3 = 'b' // 函数b的局部变量
        console.log(test2 + test3)
    }
}
```
![作用域链](../image/js/scopeChain.png)
### 二、延长作用域链
### 三、动态声明变量
### 四、块级作用域